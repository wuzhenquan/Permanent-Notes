<html>
  <body>
    <div class="bad-example">bad 1</div>
    <div class="bad-example">bad 2</div>
    <div class="bad-example">bad 3</div>
    <div class="bad-example">bad 4</div>
    <div class="bad-example">bad 5</div>
    <div class="good-example">good 1</div>
    <div class="good-example">good 2</div>
    <div class="good-example">good 3</div>
    <div class="good-example">good 4</div>
    <div class="good-example">good 5</div>
  </body>
  <script>
    const badExampleNodes = document.getElementsByClassName("bad-example");
    // 没达到期望的代码: 无论点击哪个 div，最后弹出的结果都是 5
    for (var i = 0, len = badExampleNodes.length; i < len; i++) {
      // onclick 被执行的时候会顺着作用域链找到 i，此时 i 已经叠加到 5 了
      badExampleNodes[i].onclick = () => console.log(i);
    }

    /********** 使用闭包的本质，就是给局部变量创造作用域，让变量的生存周期变为永久 **********/

    const goodExampleNodes = document.getElementsByClassName("good-example");
    // 解决方法 使用闭包:
    for (var i = 0, len = goodExampleNodes.length; i < len; i++) {
      // 用函数创建一个作用域，
      // 让 i 处于这个作用域里（这就是闭包），
      // 让执行的函数所引用的变量不被销毁。
      // onclick 被执行的时候会在这个作用域里找到 i
      (function (i) {
        goodExampleNodes[i].onclick = () => console.log(i);
      })(i);
    }

    /* 或者用 let 创建作用域 */
    for (let i = 0, len = goodExampleNodes.length; i < len; i++) {
      // 用函数将创造一个作用域，让 i 处于这个作用域里（这就是闭包）
      // onclick 被执行的时候会在这个作用域里找到 i
      goodExampleNodes[i].onclick = () => console.log(i);
    }
  </script>
</html>
