<!-- 优化前: 一开始就创建了登录浮窗 -->
<html>
  <body>
    <button id="loginBtn">登录</button>
  </body>
  <script>
    // 缺点: 一开始就创建了登录浮窗 有时候用户可能不需要登录
    const loginLayer = (function () {
      var div = document.createElement("div");
      div.innerHTML = "我是登录浮窗";
      div.style.display = "none";
      document.body.appendChild(div);
      return div;
    })();

    document.getElementById("loginBtn").onclick = function () {
      loginLayer.style.display = "block";
    };
  </script>
</html>

<!-- 优化后之一: 用户点击登录按钮时才开始创建浮窗 -->
<!-- 将上述例子改成了用户点击登录按钮时才开始创建浮窗 -->
<!-- 和上述例子的区别 只是将立即执行函数改成了非立即执行函数而已 -->
<!-- 优点: 达到了惰性的目的 -->
<!-- 缺点: 失去了单例的效果 -->
<html>
  <body>
    <button id="loginBtn">登录</button>
  </body>
  <script>
    var createLoginLayer = function () {
      const div = document.createElement("div");
      div.innerHTML = "我是登录浮窗";
      div.style.display = "none";
      document.body.appendChild(div);
      return div;
    };

    document.getElementById("loginBtn").onclick = function () {
      const loginLayer = createLoginLayer();
      loginLayer.style.display = "block";
    };
  </script>
</html>

<!-- 优化后之二 用户点击登录按钮时才开始创建浮窗 + 用一个变量来判断是否已经创建过登录浮窗 -->
<!-- 优点: 达到了惰性的目的 也拥有来单例的效果 -->
<!-- 缺点一: 违反单一职责原则 创建对象和管理单例的逻辑都放在 createLoginLayer 对象内部 -->
<!-- 缺点二: 如果我们下次需要创建页面中唯一的 iframe 标签
          用来跨域请求数据 就必须得如法炮制 把 createLoginLayer 函数几乎抄一遍 -->
<html>
  <body>
    <button id="loginBtn">登录</button>
    <button id="iframeBtn">打开 iframe</button>
  </body>
  <script>
    // 创建一个 div 标签
    var createLoginLayer = (function () {
      let div;
      return function () {
        if (!div) {
          div = document.createElement("div");
          div.innerHTML = "我是登录浮窗";
          div.style.display = "none";
          document.body.appendChild(div);
        }
        return div;
      };
    })();

    // 创建一个 iframe 标签 #管理单例的逻辑重复
    var createIframe = (function () {
      let iframe;
      return function () {
        if (!iframe) {
          iframe = document.createElement("iframe");
          div.style.display = "none";
          document.body.appendChild(iframe);
        }
        return iframe;
      };
    })();

    document.getElementById("loginBtn").onclick = function () {
      let loginLayer = createLoginLayer();
      loginLayer.style.display = "block";

      let iframeLayer = createIframe();
      loginLayer.style.display = "block";
    };
  </script>
</html>

<!-- 最终优化: 用户点击登录按钮时才开始创建浮窗 + 用一个变量来判断是否已经创建过登录浮窗 + 单一职责 -->
<!-- 这个例子中「管理单例的职责」和「创建实例对象的职责」分别放在两个方法里 -->
<!-- 优点: 两者独立变化而不互相影响 -->
<!-- 优点: 两者组合起来才具有单例模式的威力 -->
<html>
  <body>
    <button id="loginBtn">登录</button>
  </body>
  <script>
    // 管理单例的职责 (创建实例对象的职责)
    function getSingle(fn) {
      let result;
      return function () {
        return result || (result = fn.apply(this, arguments));
      };
    }

    // 创建一个 div 标签 (创建实例对象的职责)
    var createLoginLayer = function () {
      var div = document.createElement("div");
      div.innerHTML = "我是登录浮窗";
      div.style.display = "none";
      document.body.appendChild(div);
      return div;
    };
    var createSingleLoginLayer = getSingle(createLoginLayer);

    // 创建一个 iframe 标签
    var createIframe = function () {
      let iframe = document.createElement("iframe");
      document.body.appendChild(iframe);
      return iframe;
    };
    var createSigleIframe = getSingle(createIframe);

    document.getElementById("loginBtn").onclick = function () {
      var loginLayer = createSingleLoginLayer();
      loginLayer.style.display = "block";

      let loginLayer = createSigleIframe();
      loginLayer.src = "http://google.com";
    };
  </script>
</html>

<!-- 这种单例模式的用途远不止创建对象 -->
<!-- 比如渲染完页面中的一个列表后 要给这个列表绑定 click 事件 -->
<!-- click 事件实际上只需要在第一次渲染列表的时候绑定一次 -->
<html>
  <body>
    <div id="div1">div1</div>
  </body>
  <script>
    const getSingle = function (fn) {
      let result;
      return function () {
        return result || (result = fn.apply(this, arguments));
      };
    };
    const bindEvent = getSingle(function () {
      document.getElementById("div1").onclick = () => alert("click");
      return true;
    });
    const render = () => bindEvent();

    // render 函数执行了 3 次 但 div 实际上只被绑定了一次
    render();
    render();
    render();
  </script>
</html>
