 https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/15 
![三次握手四次握手](https://user-images.githubusercontent.com/23043941/61610138-c873b000-ac8a-11e9-9478-5b9197cb2288.png)

> 如果只是简单的了解这2个问题，真的那么有意义吗？所以，不防试着去多了解一点网络通信的内容，记得在上家公司的时候有个老哥说过，网络通信其实还是蛮重要的，毕竟我们现在无论是工作还是生活基本都处于互联网之中，尤其作为开发者基本上每天都在和 http 请求打交道 

**CP/IP 协议是传输层（第四）协议，主要解决数据如何在网络中传输（只负责发送任何格式的数据到网络上），而HTTP是应用层（第七）协议，主要解决如何包装数据。**关于TCP/IP和HTTP协议的关系，网络有一段比较容易理解的介绍：“我们在传输数据时，可以只使用（传输层）TCP/IP协议，但是那样的话，如果没有应用层，便无法识别数据内容，如果想要使传输的数据有意义，则必须使用到应用层协议，应用层协议有很多，比如HTTP、FTP、TELNET等，也可以自己定义应用层协议。WEB使用HTTP协议作应用层协议，以封装HTTP 文本信息，然后使用TCP/IP做传输层协议将它发到网络上。”

**三次四次的目的**： 保证 client 和 server 均让对方知道自己的接收和发送能力没问题而保证的最小次数。 

其中，为了保证后续的握手是为了应答上一个握手，每次握手都会带一个标识 seq，后续的ACK都会对这个seq进行加一来进行确认。 

3次握手是指发送了3个报文段，4次挥手是指发送了4个报文段。

#### TCP 的 6 种标识

- SYN 建立联机（用于握手）
- ACK 确认（你发的报文我收到了）
- PSH 传送
- FIN 结束（用于挥手）
- RST 重置
- URG 紧急

#### 三次握手

tcp 是全双工的，就是 A 正在给 B 发信息的同时，B 也在给 A 发信息，所以当连接的时候，必须要求双方都得知道，如果只有一方知道，肯定不行。

tcp 是全双工的，因此每个方向都必须单独进行关闭 

建立TCP连接需要三次握手才能建立 

##### 目的

建立 TCP 连接

##### 过程

##### ![img](https://mmbiz.qpic.cn/sz_mmbiz_png/H8M5QJDxMHoZnFcvSz0C3shMuMHuMX6ic9uTtyTAk13PsySibhbS6ibtpqc75yDAAgNNQIYH7aL5iaiaUAsGlKhRwYQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

第一次：A：B，你好，我是 A 请求建立连接，我的seq是0，我的win是65535，我希望本次回应我的内容长度len为0，我本次能接收的最大内容是1460，over； **让 server 知道 client 的具有发送能力**

第二次：B：A，你也好，收到你的信息了，我是B，我本次的seq是0（注意，双方的序号是独立计算的，这里都从0开始的），我回应你的ack是1(A的seq+1，代表我收到你seq是0的消息了)，我的窗口大小是8192，我希望你回应我本次消息的len也是0，我这边能接收的最大回应大小是1452，over； **让 client 知道 server 具有发送能力和接收能力**

第三次：A：好的，我收到你的回应了，我现在给你发送的seq是1(上一次是0，这次是1)，我回应你的ack是1(B的seq+1)，我当前的窗口大小是25984，我希望的回应长度是0；我们建立好连接了，over； **让 server 知道 client 具有接收能力** 

##### 每一次的目的

第一次：让 server 知道 client 的具有发送能力

第二次：让 client 知道 server 具有发送能力和接收能力

第三次：让 server 知道 client 具有接收能力

##### 为什么要三次握手

目的：确认客户端、服务端的发送能力、接收能力是正常的

- 第一次握手：客户端发送网络包，服务端收到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。
- 第二次握手：服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。
- 第三次握手：客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。

所以公认 3 次比较合理

举例子：

client 发送了第一个连接的请求报文，但是由于网络不好，这个请求**没有立即到达服务端**，而是在某个网络节点中滞留了，过了一段时间才到达 server。本来这已经是一个失效的报文，但是 server 端接收到这个请求报文后，还是会向 client 发出确认的报文，表示同意连接。

假如不采用三次握手，那么只要 server 发出确认，新的建立就连接了，但其实这个请求是失效的请求，client 是不会理睬 server 的确认信息。但是server认为新的连接已经建立起来了，并一直等待 client 发来数据，这样，server的很多资源就没白白浪费掉了。

有了第三次握手的话，server 就会因为收不到确认的报文，就知道 client 并没有建立连接。这就是第三次握手的作用。

#### 四次挥手

tcp 是全双工的，就是 A 正在给 B 发信息的同时，B 也在给 A 发信息，所以当断开的时候，必须要求双方都得知道，如果只有一方知道，肯定不行。

断开连接则需要四次挥手 

一个概念：**TCP的半关闭**， TCP提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力。 

客户端或服务器均可主动发起挥手动作。 

##### 过程

![img](https://mmbiz.qpic.cn/sz_mmbiz_png/H8M5QJDxMHoZnFcvSz0C3shMuMHuMX6icjIdX0eHjiarMPwNcMhgeUvUCgrtuhibgM1MdGwUpa5DVmficjBsW9mR6g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

第一次：前端：后端，不好意思，我这边需要关闭连接了，你准备一下？(发了一个 FIN 信号给B，等待回应)

第二次：后端：好的前端，我收到你的关闭信号了，我还有数据没发好，你等我下（回应前端，带回去ACK的最后一个信息，失败可以重发）

第三次：后端：前端老弟，我好了，我可以关闭了，给你最后说一下，等下你回应我的话，我就直接关了；（发一个 FIN 给 前端)

第四次：前端：好的老哥，我回应你一下，你收到就关闭吧，不用理我(回复一个 ACK 给 后端，发完这条信息后，进入time_wait状态)

后端：(收到 ack 信息，直接就关闭了)，此过程不产生数据的交互，不算挥手次数

前端：等待 2MSL(最大报文段生存时间)后，后端没东西给过来，我也关了；

##### 为什么要四次挥手

目的：确保数据能够完成传输。

3次：A：“你好我要关了” -> B：“稍等还有最后一个包” A：“你关闭吧不用回复了我也不收你最后一个包了”

4次：A：“你好我要关了” -> B：“稍等还有最后一个包” -> B：“好了等你回复我再关闭” -> A：“你关闭吧不用回复了”✅

握手时，服务端可以发送 SYN + ACK。

挥手时，服务端不可以发送 SYN + ACK。

因为挥手时服务端有可能还要发送数据。所以在第二次挥手时（服务端向客户端挥手）只能先回复一个 ACK 报文（告诉客户端你的 FIN 我收到了），等服务端数据发完，再向客户端第三次挥手。

##### tcp我握手的时候为何ACK(确认)和SYN(建立连接)是一起发送。挥手的时候为什么是分开的时候发送呢？

因为当 Server 端收到 Client 端的 SYN 连接请求报文后，可以直接发送 SYN+ACK 报文。其中 ACK 报文是用来应答的，SYN 报文是用来同步的。

但是关闭连接时，当 Server 端收到 FIN （结束）报文时，很可能并不会立即关闭 SOCKET，所以只能先回复一个ACK 报文，告诉 Client 端，"你发的FIN报文我收到了"。只有等到我 Server 端所有的报文都发送完了，我才能发送 FIN 报文，因此不能一起发送。故需要四步挥手。

#### 相关问题：

1.  请画出三次握手和四次挥手的示意图 
2.  为什么连接的时候是三次握手，关闭的时候却是四次握手？ 
3.  什么是半连接队列？ 
4.  ISN(Initial Sequence Number)是固定的吗？ 
5.  三次握手过程中可以携带数据吗？ 
6.  如果第三次握手丢失了，客户端服务端会如何处理？ 
7.  SYN攻击是什么？ 
8.  四次挥手释放连接时，等待2MSL的意义? 

参考

 https://juejin.im/post/5c078058f265da611c26c235 

 https://mp.weixin.qq.com/s/WI9045Sd7gRsE-WZ5x8tcA 

https://mp.weixin.qq.com/s/2K_ZscEgoAIRrze03Bik6A