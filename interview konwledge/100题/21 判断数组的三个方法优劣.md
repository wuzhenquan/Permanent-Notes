### Object.prototype.toString.call()

`Object.prototype.toString.call(arr)` 并没有改变 `this`，而是改变了调用的函数。

`toString` 如果没有被重写，会返回 `[Object type] `，利用 call 使用没有重写的 `toString` 就好了。

### Array.isArray()

- instanceof 与 isArray

  当检测Array实例时，`Array.isArray` **优于**  `instanceof` ，因为 `Array.isArray` 可以检测出 `iframes`

  ```js
  var iframe = document.createElement('iframe');
  document.body.appendChild(iframe);
  xArray = window.frames[window.frames.length-1].Array;
  var arr = new xArray(1,2,3); // [1,2,3]
  
  // Correctly checking for Array
  Array.isArray(arr);  // true
  Object.prototype.toString.call(arr); // true
  // Considered harmful, because doesn't work though iframes
  arr instanceof Array; // false
  ```

- `Array.isArray()` 与 `Object.prototype.toString.call()`

  `Array.isArray()`是**ES5新增**的方法，当不存在 `Array.isArray()` ，可以用 `Object.prototype.toString.call()` 实现。

  ```js
  if (!Array.isArray) {
    Array.isArray = function(arg) {
      return Object.prototype.toString.call(arg) === '[object Array]';
    };
  }
  ```

### constructor

https://www.cnblogs.com/onepixel/p/5126046.html

可以看出，F 利用原型对象上的 constructor 引用了自身，当 F 作为构造函数来创建对象时，原型上的 constructor 就被遗传到了新创建的对象上， 从原型链角度讲，构造函数 F 就是新对象的类型。这样做的意义是，让新对象在诞生以后，就具有可追溯的数据类型。

同样，JavaScript 中的内置对象在内部构建时也是这样做的：

```js
''.constructor === String
new Number(1).constructor === Number
true.constructor === Boolean
new Function().constructor === Function
new Date().constructor === Date
new Error().constructor === Error
[].constructor === Array
document.constructor === HTMLDocument
window.constructor === Window
```

但，construct 可以被修改

### instanceof ❎

使用 `instanceof`判断一个对象是否为数组，`instanceof` 会判断这个对象的原型链上是否会找到对应的 `Array` 的原型

为什么 `[]  instanceof Object; // true` ?

`[ ].__proto__`  指向 Array.prototype，而 `Array.prototype.__proto__` 又指向了Object.prototype，最终 `Object.prototype.__proto__` 指向了null，标志着原型链的结束。

但，instanceof 不能校验原始值类型

```js
'a' instanceof String
// false
```

但，instanceof 是判断类型的 prototype 是否出现在对象的原型链中，但是对象的原型可以随意修改，所以这种判断并不准确。

```js
const obj = {}
obj.__proto__ = Array.prototype
// Object.setPrototypeOf(obj, Array.prototype)
obj instanceof Array // true
```



https://www.cnblogs.com/onepixel/p/5126046.html

https://www.cnblogs.com/onepixel/p/5126046.html